# C++智能指针

> [【C++现代实用教程:智能指针】](https://www.bilibili.com/video/BV18B4y187uL/?share_source=copy_web&vd_source=724ca2fcd803a56b1646d6d28e65b820)

## unique_ptr

### unique_ptr Intro

- 三种创建方式
  - 通过已有裸指针创建
  - 通过new创建
  - 通过std::make_unique创建（推荐）
- unique_ptr可以通过get()获取地址
- unique_ptr实现了->与*
  - 可以通过->调用成员函数
  - 可以通过*调用dereferencing

### 函数调用与unique_ptr注意事项

- unique_ptr不可copy，只可move
- Passing by value
  - 需要用std::move来转移内存拥有权
  - 如果参数直接传入std::make_unique语句 自动转换为move
- Passing by reference
  - 传入unique_ptr&，可以保持内存拥有权
  - 传入const unique_ptr&，可以保持内存拥有权，但无法修改内容
    - 比方说reset()
  - reset()方法为智能指针清空方法
- Return by value
  - 指向一个local object
  - 可以用作链式函数

## shared_ptr

### shared_ptr Intro

- shared_ptr创建了一个计数器与类对象所指的内存相关联
- copy则计数器加一，销毁则计数器减一
- api为ues_count()

### shared_ptr与函数

- shared_ptr passed by value
  - copy
  - 函数内部计数器加一
- shared_ptr passed by reference
  - const表示不课改变指向
- returning by value
  - 链式调用

## shared_ptr与unique_ptr

- 不能将shared_ptr转为unique_ptr
- 但可以将unique_ptr转为shared_ptr
  - 通过std::move
- 常见的设计模式
  - 将你的函数返回unique_ptr是一种常见的设计模式，这样可以提高代码的复用度，你可以随时改变为shared_ptr

## weak_ptr

### weak_ptr Intro

- weak_ptr并不拥有所有权
- 并不能调用->和解饮用*

### weak_ptr为什么存在

- A类种有一个需求需要存储其他A类对象的信息
- 如果使用shared_ptr，那么在销毁时会遇到循环依赖问题（Cyclic dependency problem），即shared_ptr的计数器不会为0
- 所以我们这里需要用一个不需要游泳所有权的指针来标记该同类对象
  - weak_ptr可以通过lock()函数来提升为shared_ptr（类型转换）

-----

## C++ 中的所有权

> Generated by Claude 3 Opus

所有权是 C++ 中的一个重要概念,特别是在使用智能指针时。它决定了哪个对象负责管理动态分配的资源,以及该资源的生命周期。

### 独占所有权 (`unique_ptr`)

- 只能有一个 `unique_ptr` 拥有对象
- 禁止拷贝,但允许通过 `std::move` 转移所有权

### 共享所有权 (`shared_ptr`)

- 多个 `shared_ptr` 可以同时拥有同一个对象
- 使用引用计数来跟踪所有权
- 允许拷贝操作,拷贝时引用计数会增加

### 裸指针和所有权

- 裸指针本身不具有所有权的概念
- 裸指针只是指向对象的地址,不负责对象的生命周期管理

### 所有权转移

- 将对象的管理权从一个智能指针转移到另一个智能指针
- `unique_ptr` 使用 `std::move` 转移所有权
- `shared_ptr` 通过拷贝操作共享所有权

所有权帮助我们明确资源管理的责任,避免内存泄漏和悬空指针等问题。在现代 C++ 中,推荐使用智能指针来管理动态分配的资源。
