# Python深拷贝和浅拷贝

> [彻底理解Python中浅拷贝和深拷贝的区别](https://blog.csdn.net/lovedingd/article/details/128257172)

## Intro

Python的所有变量都是指向内存中的对象的一个指针，所以所有的变量无类型限制，可以任意指定对象。指针的内存空间大小与类型无关，只是被存了所指向数据的内存地址。

对象还分为两类：

- 可修改（mutable）的对象
  - list, dict, set, bytearray, user-defined classes (unless specifically made immutable)
- 不可修改（immutable）的对象
  - int, float, decimal, complex, bool, str, tuple, range, frozenset, bytes

可以通过内置函数id()来探索对象在在内存的存储，用于返回对象的身份（唯一标识符），为该对象的内存地址。

```python
a = 1
print(id(a)) # 内存的十进制表示
print(hex(id(a))) # 内存的十六进制表示
```

## 浅拷贝和深拷贝的概念

浅拷贝：

> 浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。即默认拷贝构造函数只是对对象进行浅拷贝复制(逐个成员依次拷贝)，即只复制对象空间而不复制资源。

深拷贝：

> 深拷贝会拷贝所有的属性，并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。源对象与拷贝对象互相独立，其中任何一个对象的改动都不会对另外一个对象造成影响。深拷贝相比于浅拷贝速度较慢并且花销较大。

简单来说，浅拷贝只复制某个对象的引用，而不复制对象本身，新旧对象还是共享同一快内存；深拷贝会创造一个一模一样的对象，新对象和原对象不共享内存，修改新对象不会改变原对象。

在python中：

- 浅拷贝copy()拷贝父对象，不会拷贝对象内部的子对象。
- 深拷贝deepcopy()是copy模块中的方法，完全拷贝了子对象和父对象。

## is和==的区别

python对象含有三种基本元素：id返回对象地址，type返回对象的数据类型，value返回对象的值。

is和==都可以对两个对象进行比较，切返回值均为bool。但是它们的比较内容是不同的。

- is比较的是两个对象的地址值
- ==比较的是两个对象的值是否相等，其调用了对象的__eq__()方法

```python
In [1]: ls1 = [1, 2, 3, 4]

In [2]: id(ls1)
Out[2]: 4399526720

In [3]: type(ls1)
Out[3]: list

In [4]: ls2 = [1, 2, 3, 4]

In [5]: id(ls2)
Out[5]: 4403741184

In [6]: ls2 == ls1
Out[6]: True

In [7]: ls2 is ls1
Out[7]: False

In [8]: ls2 = ls1

In [9]: id(ls2)
Out[9]: 4399526720

In [10]: id(ls1)
Out[10]: 4399526720

In [11]: ls1 is ls2
Out[11]: True
```

## 赋值操作

赋值操作实际上是对象的引用。当创建一个对象，然后把它赋值给另一个变量的时候，python并没有拷贝这个对象，而只是拷贝了这个对象的引用。

```python
In [7]: ls = [1, 2, 3, 4]

In [8]: ls1 = ls

In [9]: ls.append(5)

In [10]: ls1
Out[10]: [1, 2, 3, 4, 5]
```
